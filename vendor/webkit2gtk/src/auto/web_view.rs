// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
use crate::AuthenticationRequest;
#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
use crate::AutomationBrowsingContextPresentation;
use crate::BackForwardList;
use crate::BackForwardListItem;
#[cfg(any(feature = "v2_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
use crate::ColorChooserRequest;
use crate::ContextMenu;
use crate::Download;
#[cfg(any(feature = "v2_10", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_10")))]
use crate::EditorState;
use crate::FileChooserRequest;
use crate::FindController;
use crate::FormSubmissionRequest;
use crate::HitTestResult;
#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
use crate::InputMethodContext;
use crate::InsecureContentEvent;
use crate::JavascriptResult;
use crate::LoadEvent;
#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
use crate::NavigationAction;
#[cfg(any(feature = "v2_8", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
use crate::Notification;
#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
use crate::OptionMenu;
use crate::PermissionRequest;
use crate::PolicyDecision;
use crate::PolicyDecisionType;
use crate::PrintOperation;
use crate::SaveMode;
use crate::ScriptDialog;
use crate::Settings;
use crate::SnapshotOptions;
use crate::SnapshotRegion;
use crate::URIRequest;
#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
use crate::UserContentManager;
#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
use crate::UserMessage;
use crate::WebContext;
use crate::WebInspector;
#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
use crate::WebProcessTerminationReason;
use crate::WebResource;
use crate::WebViewBase;
#[cfg(any(feature = "v2_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
use crate::WebViewSessionState;
#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
use crate::WebsiteDataManager;
#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
use crate::WebsitePolicies;
use crate::WindowProperties;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem;
use std::mem::transmute;
use std::pin::Pin;
use std::ptr;

glib::wrapper! {
    #[doc(alias = "WebKitWebView")]
    pub struct WebView(Object<ffi::WebKitWebView, ffi::WebKitWebViewClass>) @extends WebViewBase, gtk::Container, gtk::Widget;

    match fn {
        type_ => || ffi::webkit_web_view_get_type(),
    }
}

impl WebView {
    #[doc(alias = "webkit_web_view_new")]
    pub fn new() -> WebView {
        assert_initialized_main_thread!();
        unsafe {
            gtk::Widget::from_glib_none(ffi::webkit_web_view_new()).unsafe_cast()
        }
    }

    #[doc(alias = "webkit_web_view_new_with_context")]
    #[doc(alias = "new_with_context")]
    pub fn with_context<P: IsA<WebContext>>(context: &P) -> WebView {
        skip_assert_initialized!();
        unsafe {
            gtk::Widget::from_glib_none(ffi::webkit_web_view_new_with_context(context.as_ref().to_glib_none().0)).unsafe_cast()
        }
    }

    #[cfg(any(feature = "v2_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
    #[doc(alias = "webkit_web_view_new_with_related_view")]
    #[doc(alias = "new_with_related_view")]
    pub fn with_related_view<P: IsA<WebView>>(web_view: &P) -> WebView {
        skip_assert_initialized!();
        unsafe {
            gtk::Widget::from_glib_full(ffi::webkit_web_view_new_with_related_view(web_view.as_ref().to_glib_none().0)).unsafe_cast()
        }
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    #[doc(alias = "webkit_web_view_new_with_settings")]
    #[doc(alias = "new_with_settings")]
    pub fn with_settings<P: IsA<Settings>>(settings: &P) -> WebView {
        skip_assert_initialized!();
        unsafe {
            gtk::Widget::from_glib_none(ffi::webkit_web_view_new_with_settings(settings.as_ref().to_glib_none().0)).unsafe_cast()
        }
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    #[doc(alias = "webkit_web_view_new_with_user_content_manager")]
    #[doc(alias = "new_with_user_content_manager")]
    pub fn with_user_content_manager<P: IsA<UserContentManager>>(user_content_manager: &P) -> WebView {
        skip_assert_initialized!();
        unsafe {
            gtk::Widget::from_glib_none(ffi::webkit_web_view_new_with_user_content_manager(user_content_manager.as_ref().to_glib_none().0)).unsafe_cast()
        }
    }

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`WebView`] objects.
            ///
            /// This method returns an instance of [`WebViewBuilder`] which can be used to create [`WebView`] objects.
            pub fn builder() -> WebViewBuilder {
                WebViewBuilder::default()
            }
        
}

impl Default for WebView {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Clone, Default)]
// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`WebView`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
pub struct WebViewBuilder {
    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    automation_presentation_type: Option<AutomationBrowsingContextPresentation>,
    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    editable: Option<bool>,
    #[cfg(any(feature = "v2_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_18")))]
    is_controlled_by_automation: Option<bool>,
    #[cfg(any(feature = "v2_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
    is_ephemeral: Option<bool>,
    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    is_muted: Option<bool>,
    #[cfg(any(feature = "v2_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
    related_view: Option<WebView>,
    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    settings: Option<Settings>,
    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    user_content_manager: Option<UserContentManager>,
    web_context: Option<WebContext>,
    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    website_policies: Option<WebsitePolicies>,
    zoom_level: Option<f64>,
    border_width: Option<u32>,
    child: Option<gtk::Widget>,
    //resize-mode: /*Unknown type*/,
    app_paintable: Option<bool>,
    can_default: Option<bool>,
    can_focus: Option<bool>,
    #[cfg(any(feature = "v2_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_18")))]
    #[cfg_attr(feature = "v3_14", deprecated = "Since 3.14")]
    double_buffered: Option<bool>,
    //events: /*Unknown type*/,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    expand: Option<bool>,
    #[cfg(any(feature = "v3_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
    focus_on_click: Option<bool>,
    //halign: /*Unknown type*/,
    has_default: Option<bool>,
    has_focus: Option<bool>,
    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    has_tooltip: Option<bool>,
    height_request: Option<i32>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    hexpand: Option<bool>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    hexpand_set: Option<bool>,
    is_focus: Option<bool>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    margin: Option<i32>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    margin_bottom: Option<i32>,
    #[cfg(any(feature = "v3_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
    margin_end: Option<i32>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    #[cfg_attr(feature = "v3_12", deprecated = "Since 3.12")]
    margin_left: Option<i32>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    #[cfg_attr(feature = "v3_12", deprecated = "Since 3.12")]
    margin_right: Option<i32>,
    #[cfg(any(feature = "v3_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
    margin_start: Option<i32>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    margin_top: Option<i32>,
    name: Option<String>,
    no_show_all: Option<bool>,
    #[cfg(any(feature = "v3_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_8")))]
    opacity: Option<f64>,
    parent: Option<gtk::Container>,
    receives_default: Option<bool>,
    sensitive: Option<bool>,
    //style: /*Unknown type*/,
    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    tooltip_markup: Option<String>,
    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    tooltip_text: Option<String>,
    //valign: /*Unknown type*/,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    vexpand: Option<bool>,
    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    vexpand_set: Option<bool>,
    visible: Option<bool>,
    width_request: Option<i32>,
}

impl WebViewBuilder {
    // rustdoc-stripper-ignore-next
    /// Create a new [`WebViewBuilder`].
    pub fn new() -> Self {
        Self::default()
    }


    // rustdoc-stripper-ignore-next
    /// Build the [`WebView`].
    pub fn build(self) -> WebView {
        let mut properties: Vec<(&str, &dyn ToValue)> = vec![];
        #[cfg(any(feature = "v2_28", feature = "dox"))]
if let Some(ref automation_presentation_type) = self.automation_presentation_type {
                properties.push(("automation-presentation-type", automation_presentation_type));
            }
        #[cfg(any(feature = "v2_8", feature = "dox"))]
if let Some(ref editable) = self.editable {
                properties.push(("editable", editable));
            }
        #[cfg(any(feature = "v2_18", feature = "dox"))]
if let Some(ref is_controlled_by_automation) = self.is_controlled_by_automation {
                properties.push(("is-controlled-by-automation", is_controlled_by_automation));
            }
        #[cfg(any(feature = "v2_16", feature = "dox"))]
if let Some(ref is_ephemeral) = self.is_ephemeral {
                properties.push(("is-ephemeral", is_ephemeral));
            }
        #[cfg(any(feature = "v2_30", feature = "dox"))]
if let Some(ref is_muted) = self.is_muted {
                properties.push(("is-muted", is_muted));
            }
        #[cfg(any(feature = "v2_4", feature = "dox"))]
if let Some(ref related_view) = self.related_view {
                properties.push(("related-view", related_view));
            }
        #[cfg(any(feature = "v2_6", feature = "dox"))]
if let Some(ref settings) = self.settings {
                properties.push(("settings", settings));
            }
        #[cfg(any(feature = "v2_6", feature = "dox"))]
if let Some(ref user_content_manager) = self.user_content_manager {
                properties.push(("user-content-manager", user_content_manager));
            }
if let Some(ref web_context) = self.web_context {
                properties.push(("web-context", web_context));
            }
        #[cfg(any(feature = "v2_30", feature = "dox"))]
if let Some(ref website_policies) = self.website_policies {
                properties.push(("website-policies", website_policies));
            }
if let Some(ref zoom_level) = self.zoom_level {
                properties.push(("zoom-level", zoom_level));
            }
if let Some(ref border_width) = self.border_width {
                properties.push(("border-width", border_width));
            }
if let Some(ref child) = self.child {
                properties.push(("child", child));
            }
if let Some(ref app_paintable) = self.app_paintable {
                properties.push(("app-paintable", app_paintable));
            }
if let Some(ref can_default) = self.can_default {
                properties.push(("can-default", can_default));
            }
if let Some(ref can_focus) = self.can_focus {
                properties.push(("can-focus", can_focus));
            }
        #[cfg(any(feature = "v2_18", feature = "dox"))]
if let Some(ref double_buffered) = self.double_buffered {
                properties.push(("double-buffered", double_buffered));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref expand) = self.expand {
                properties.push(("expand", expand));
            }
        #[cfg(any(feature = "v3_20", feature = "dox"))]
if let Some(ref focus_on_click) = self.focus_on_click {
                properties.push(("focus-on-click", focus_on_click));
            }
if let Some(ref has_default) = self.has_default {
                properties.push(("has-default", has_default));
            }
if let Some(ref has_focus) = self.has_focus {
                properties.push(("has-focus", has_focus));
            }
        #[cfg(any(feature = "v2_12", feature = "dox"))]
if let Some(ref has_tooltip) = self.has_tooltip {
                properties.push(("has-tooltip", has_tooltip));
            }
if let Some(ref height_request) = self.height_request {
                properties.push(("height-request", height_request));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref hexpand) = self.hexpand {
                properties.push(("hexpand", hexpand));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref hexpand_set) = self.hexpand_set {
                properties.push(("hexpand-set", hexpand_set));
            }
if let Some(ref is_focus) = self.is_focus {
                properties.push(("is-focus", is_focus));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref margin) = self.margin {
                properties.push(("margin", margin));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref margin_bottom) = self.margin_bottom {
                properties.push(("margin-bottom", margin_bottom));
            }
        #[cfg(any(feature = "v3_12", feature = "dox"))]
if let Some(ref margin_end) = self.margin_end {
                properties.push(("margin-end", margin_end));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref margin_left) = self.margin_left {
                properties.push(("margin-left", margin_left));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref margin_right) = self.margin_right {
                properties.push(("margin-right", margin_right));
            }
        #[cfg(any(feature = "v3_12", feature = "dox"))]
if let Some(ref margin_start) = self.margin_start {
                properties.push(("margin-start", margin_start));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref margin_top) = self.margin_top {
                properties.push(("margin-top", margin_top));
            }
if let Some(ref name) = self.name {
                properties.push(("name", name));
            }
if let Some(ref no_show_all) = self.no_show_all {
                properties.push(("no-show-all", no_show_all));
            }
        #[cfg(any(feature = "v3_8", feature = "dox"))]
if let Some(ref opacity) = self.opacity {
                properties.push(("opacity", opacity));
            }
if let Some(ref parent) = self.parent {
                properties.push(("parent", parent));
            }
if let Some(ref receives_default) = self.receives_default {
                properties.push(("receives-default", receives_default));
            }
if let Some(ref sensitive) = self.sensitive {
                properties.push(("sensitive", sensitive));
            }
        #[cfg(any(feature = "v2_12", feature = "dox"))]
if let Some(ref tooltip_markup) = self.tooltip_markup {
                properties.push(("tooltip-markup", tooltip_markup));
            }
        #[cfg(any(feature = "v2_12", feature = "dox"))]
if let Some(ref tooltip_text) = self.tooltip_text {
                properties.push(("tooltip-text", tooltip_text));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref vexpand) = self.vexpand {
                properties.push(("vexpand", vexpand));
            }
        #[cfg(any(feature = "v3_0", feature = "dox"))]
if let Some(ref vexpand_set) = self.vexpand_set {
                properties.push(("vexpand-set", vexpand_set));
            }
if let Some(ref visible) = self.visible {
                properties.push(("visible", visible));
            }
if let Some(ref width_request) = self.width_request {
                properties.push(("width-request", width_request));
            }
        glib::Object::new::<WebView>(&properties)
                .expect("Failed to create an instance of WebView")

    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    pub fn automation_presentation_type(mut self, automation_presentation_type: AutomationBrowsingContextPresentation) -> Self {
        self.automation_presentation_type = Some(automation_presentation_type);
        self
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    pub fn editable(mut self, editable: bool) -> Self {
        self.editable = Some(editable);
        self
    }

    #[cfg(any(feature = "v2_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_18")))]
    pub fn is_controlled_by_automation(mut self, is_controlled_by_automation: bool) -> Self {
        self.is_controlled_by_automation = Some(is_controlled_by_automation);
        self
    }

    #[cfg(any(feature = "v2_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
    pub fn is_ephemeral(mut self, is_ephemeral: bool) -> Self {
        self.is_ephemeral = Some(is_ephemeral);
        self
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    pub fn is_muted(mut self, is_muted: bool) -> Self {
        self.is_muted = Some(is_muted);
        self
    }

    #[cfg(any(feature = "v2_4", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_4")))]
    pub fn related_view<P: IsA<WebView>>(mut self, related_view: &P) -> Self {
        self.related_view = Some(related_view.clone().upcast());
        self
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    pub fn settings<P: IsA<Settings>>(mut self, settings: &P) -> Self {
        self.settings = Some(settings.clone().upcast());
        self
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    pub fn user_content_manager<P: IsA<UserContentManager>>(mut self, user_content_manager: &P) -> Self {
        self.user_content_manager = Some(user_content_manager.clone().upcast());
        self
    }

    pub fn web_context<P: IsA<WebContext>>(mut self, web_context: &P) -> Self {
        self.web_context = Some(web_context.clone().upcast());
        self
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    pub fn website_policies<P: IsA<WebsitePolicies>>(mut self, website_policies: &P) -> Self {
        self.website_policies = Some(website_policies.clone().upcast());
        self
    }

    pub fn zoom_level(mut self, zoom_level: f64) -> Self {
        self.zoom_level = Some(zoom_level);
        self
    }

    pub fn border_width(mut self, border_width: u32) -> Self {
        self.border_width = Some(border_width);
        self
    }

    pub fn child<P: IsA<gtk::Widget>>(mut self, child: &P) -> Self {
        self.child = Some(child.clone().upcast());
        self
    }

    pub fn app_paintable(mut self, app_paintable: bool) -> Self {
        self.app_paintable = Some(app_paintable);
        self
    }

    pub fn can_default(mut self, can_default: bool) -> Self {
        self.can_default = Some(can_default);
        self
    }

    pub fn can_focus(mut self, can_focus: bool) -> Self {
        self.can_focus = Some(can_focus);
        self
    }

    #[cfg(any(feature = "v2_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_18")))]
    #[cfg_attr(feature = "v3_14", deprecated = "Since 3.14")]
    pub fn double_buffered(mut self, double_buffered: bool) -> Self {
        self.double_buffered = Some(double_buffered);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn expand(mut self, expand: bool) -> Self {
        self.expand = Some(expand);
        self
    }

    #[cfg(any(feature = "v3_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_20")))]
    pub fn focus_on_click(mut self, focus_on_click: bool) -> Self {
        self.focus_on_click = Some(focus_on_click);
        self
    }

    pub fn has_default(mut self, has_default: bool) -> Self {
        self.has_default = Some(has_default);
        self
    }

    pub fn has_focus(mut self, has_focus: bool) -> Self {
        self.has_focus = Some(has_focus);
        self
    }

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    pub fn has_tooltip(mut self, has_tooltip: bool) -> Self {
        self.has_tooltip = Some(has_tooltip);
        self
    }

    pub fn height_request(mut self, height_request: i32) -> Self {
        self.height_request = Some(height_request);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn hexpand(mut self, hexpand: bool) -> Self {
        self.hexpand = Some(hexpand);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn hexpand_set(mut self, hexpand_set: bool) -> Self {
        self.hexpand_set = Some(hexpand_set);
        self
    }

    pub fn is_focus(mut self, is_focus: bool) -> Self {
        self.is_focus = Some(is_focus);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn margin(mut self, margin: i32) -> Self {
        self.margin = Some(margin);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn margin_bottom(mut self, margin_bottom: i32) -> Self {
        self.margin_bottom = Some(margin_bottom);
        self
    }

    #[cfg(any(feature = "v3_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
    pub fn margin_end(mut self, margin_end: i32) -> Self {
        self.margin_end = Some(margin_end);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    #[cfg_attr(feature = "v3_12", deprecated = "Since 3.12")]
    pub fn margin_left(mut self, margin_left: i32) -> Self {
        self.margin_left = Some(margin_left);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    #[cfg_attr(feature = "v3_12", deprecated = "Since 3.12")]
    pub fn margin_right(mut self, margin_right: i32) -> Self {
        self.margin_right = Some(margin_right);
        self
    }

    #[cfg(any(feature = "v3_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
    pub fn margin_start(mut self, margin_start: i32) -> Self {
        self.margin_start = Some(margin_start);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn margin_top(mut self, margin_top: i32) -> Self {
        self.margin_top = Some(margin_top);
        self
    }

    pub fn name(mut self, name: &str) -> Self {
        self.name = Some(name.to_string());
        self
    }

    pub fn no_show_all(mut self, no_show_all: bool) -> Self {
        self.no_show_all = Some(no_show_all);
        self
    }

    #[cfg(any(feature = "v3_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_8")))]
    pub fn opacity(mut self, opacity: f64) -> Self {
        self.opacity = Some(opacity);
        self
    }

    pub fn parent<P: IsA<gtk::Container>>(mut self, parent: &P) -> Self {
        self.parent = Some(parent.clone().upcast());
        self
    }

    pub fn receives_default(mut self, receives_default: bool) -> Self {
        self.receives_default = Some(receives_default);
        self
    }

    pub fn sensitive(mut self, sensitive: bool) -> Self {
        self.sensitive = Some(sensitive);
        self
    }

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    pub fn tooltip_markup(mut self, tooltip_markup: &str) -> Self {
        self.tooltip_markup = Some(tooltip_markup.to_string());
        self
    }

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    pub fn tooltip_text(mut self, tooltip_text: &str) -> Self {
        self.tooltip_text = Some(tooltip_text.to_string());
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn vexpand(mut self, vexpand: bool) -> Self {
        self.vexpand = Some(vexpand);
        self
    }

    #[cfg(any(feature = "v3_0", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_0")))]
    pub fn vexpand_set(mut self, vexpand_set: bool) -> Self {
        self.vexpand_set = Some(vexpand_set);
        self
    }

    pub fn visible(mut self, visible: bool) -> Self {
        self.visible = Some(visible);
        self
    }

    pub fn width_request(mut self, width_request: i32) -> Self {
        self.width_request = Some(width_request);
        self
    }
}

pub const NONE_WEB_VIEW: Option<&WebView> = None;

pub trait WebViewExt: 'static {
    #[doc(alias = "webkit_web_view_can_execute_editing_command")]
    fn can_execute_editing_command<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, command: &str, cancellable: Option<&P>, callback: Q);

    
    fn can_execute_editing_command_future(&self, command: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    #[doc(alias = "webkit_web_view_can_go_back")]
    fn can_go_back(&self) -> bool;

    #[doc(alias = "webkit_web_view_can_go_forward")]
    fn can_go_forward(&self) -> bool;

    #[doc(alias = "webkit_web_view_can_show_mime_type")]
    fn can_show_mime_type(&self, mime_type: &str) -> bool;

    #[doc(alias = "webkit_web_view_download_uri")]
    fn download_uri(&self, uri: &str) -> Option<Download>;

    #[doc(alias = "webkit_web_view_execute_editing_command")]
    fn execute_editing_command(&self, command: &str);

    #[cfg(any(feature = "v2_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_10")))]
    #[doc(alias = "webkit_web_view_execute_editing_command_with_argument")]
    fn execute_editing_command_with_argument(&self, command: &str, argument: &str);

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    #[doc(alias = "webkit_web_view_get_automation_presentation_type")]
    #[doc(alias = "get_automation_presentation_type")]
    fn automation_presentation_type(&self) -> AutomationBrowsingContextPresentation;

    #[doc(alias = "webkit_web_view_get_back_forward_list")]
    #[doc(alias = "get_back_forward_list")]
    fn back_forward_list(&self) -> Option<BackForwardList>;

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "webkit_web_view_get_background_color")]
    #[doc(alias = "get_background_color")]
    fn background_color(&self) -> gdk::RGBA;

    #[doc(alias = "webkit_web_view_get_context")]
    #[doc(alias = "get_context")]
    fn context(&self) -> Option<WebContext>;

    #[doc(alias = "webkit_web_view_get_custom_charset")]
    #[doc(alias = "get_custom_charset")]
    fn custom_charset(&self) -> Option<glib::GString>;

    #[cfg(any(feature = "v2_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_10")))]
    #[doc(alias = "webkit_web_view_get_editor_state")]
    #[doc(alias = "get_editor_state")]
    fn editor_state(&self) -> Option<EditorState>;

    #[doc(alias = "webkit_web_view_get_estimated_load_progress")]
    #[doc(alias = "get_estimated_load_progress")]
    fn estimated_load_progress(&self) -> f64;

    #[doc(alias = "webkit_web_view_get_favicon")]
    #[doc(alias = "get_favicon")]
    fn favicon(&self) -> Option<cairo::Surface>;

    #[doc(alias = "webkit_web_view_get_find_controller")]
    #[doc(alias = "get_find_controller")]
    fn find_controller(&self) -> Option<FindController>;

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    #[doc(alias = "webkit_web_view_get_input_method_context")]
    #[doc(alias = "get_input_method_context")]
    fn input_method_context(&self) -> Option<InputMethodContext>;

    #[doc(alias = "webkit_web_view_get_inspector")]
    #[doc(alias = "get_inspector")]
    fn inspector(&self) -> Option<WebInspector>;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    #[doc(alias = "webkit_web_view_get_is_muted")]
    #[doc(alias = "get_is_muted")]
    fn is_muted(&self) -> bool;

    #[cfg_attr(feature = "v2_22", deprecated = "Since 2.22")]
    #[doc(alias = "webkit_web_view_get_javascript_global_context")]
    #[doc(alias = "get_javascript_global_context")]
    fn javascript_global_context(&self) -> Option<java_script_core::GlobalContextRef>;

    #[doc(alias = "webkit_web_view_get_main_resource")]
    #[doc(alias = "get_main_resource")]
    fn main_resource(&self) -> Option<WebResource>;

    #[doc(alias = "webkit_web_view_get_page_id")]
    #[doc(alias = "get_page_id")]
    fn page_id(&self) -> u64;

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    #[doc(alias = "webkit_web_view_get_session_state")]
    #[doc(alias = "get_session_state")]
    fn session_state(&self) -> Option<WebViewSessionState>;

    #[doc(alias = "webkit_web_view_get_settings")]
    #[doc(alias = "get_settings")]
    fn settings(&self) -> Option<Settings>;

    #[doc(alias = "webkit_web_view_get_snapshot")]
    #[doc(alias = "get_snapshot")]
    fn snapshot<P: IsA<gio::Cancellable>, Q: FnOnce(Result<cairo::Surface, glib::Error>) + Send + 'static>(&self, region: SnapshotRegion, options: SnapshotOptions, cancellable: Option<&P>, callback: Q);

    
    fn snapshot_future(&self, region: SnapshotRegion, options: SnapshotOptions) -> Pin<Box_<dyn std::future::Future<Output = Result<cairo::Surface, glib::Error>> + 'static>>;

    #[doc(alias = "webkit_web_view_get_title")]
    #[doc(alias = "get_title")]
    fn title(&self) -> Option<glib::GString>;

    #[doc(alias = "webkit_web_view_get_tls_info")]
    #[doc(alias = "get_tls_info")]
    fn tls_info(&self) -> Option<(gio::TlsCertificate, gio::TlsCertificateFlags)>;

    #[doc(alias = "webkit_web_view_get_uri")]
    #[doc(alias = "get_uri")]
    fn uri(&self) -> Option<glib::GString>;

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    #[doc(alias = "webkit_web_view_get_user_content_manager")]
    #[doc(alias = "get_user_content_manager")]
    fn user_content_manager(&self) -> Option<UserContentManager>;

    #[cfg(any(feature = "v2_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
    #[doc(alias = "webkit_web_view_get_website_data_manager")]
    #[doc(alias = "get_website_data_manager")]
    fn website_data_manager(&self) -> Option<WebsiteDataManager>;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    #[doc(alias = "webkit_web_view_get_website_policies")]
    #[doc(alias = "get_website_policies")]
    fn website_policies(&self) -> Option<WebsitePolicies>;

    #[doc(alias = "webkit_web_view_get_window_properties")]
    #[doc(alias = "get_window_properties")]
    fn window_properties(&self) -> Option<WindowProperties>;

    #[doc(alias = "webkit_web_view_get_zoom_level")]
    #[doc(alias = "get_zoom_level")]
    fn zoom_level(&self) -> f64;

    #[doc(alias = "webkit_web_view_go_back")]
    fn go_back(&self);

    #[doc(alias = "webkit_web_view_go_forward")]
    fn go_forward(&self);

    #[doc(alias = "webkit_web_view_go_to_back_forward_list_item")]
    fn go_to_back_forward_list_item<P: IsA<BackForwardListItem>>(&self, list_item: &P);

    #[cfg(any(feature = "v2_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_18")))]
    #[doc(alias = "webkit_web_view_is_controlled_by_automation")]
    fn is_controlled_by_automation(&self) -> bool;

    #[doc(alias = "webkit_web_view_is_editable")]
    fn is_editable(&self) -> bool;

    #[cfg(any(feature = "v2_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
    #[doc(alias = "webkit_web_view_is_ephemeral")]
    fn is_ephemeral(&self) -> bool;

    #[doc(alias = "webkit_web_view_is_loading")]
    fn is_loading(&self) -> bool;

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "webkit_web_view_is_playing_audio")]
    fn is_playing_audio(&self) -> bool;

    #[doc(alias = "webkit_web_view_load_alternate_html")]
    fn load_alternate_html(&self, content: &str, content_uri: &str, base_uri: Option<&str>);

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    #[doc(alias = "webkit_web_view_load_bytes")]
    fn load_bytes(&self, bytes: &glib::Bytes, mime_type: Option<&str>, encoding: Option<&str>, base_uri: Option<&str>);

    #[doc(alias = "webkit_web_view_load_html")]
    fn load_html(&self, content: &str, base_uri: Option<&str>);

    #[doc(alias = "webkit_web_view_load_plain_text")]
    fn load_plain_text(&self, plain_text: &str);

    #[doc(alias = "webkit_web_view_load_request")]
    fn load_request<P: IsA<URIRequest>>(&self, request: &P);

    #[doc(alias = "webkit_web_view_load_uri")]
    fn load_uri(&self, uri: &str);

    #[doc(alias = "webkit_web_view_reload")]
    fn reload(&self);

    #[doc(alias = "webkit_web_view_reload_bypass_cache")]
    fn reload_bypass_cache(&self);

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    #[doc(alias = "webkit_web_view_restore_session_state")]
    fn restore_session_state(&self, state: &WebViewSessionState);

    #[doc(alias = "webkit_web_view_run_javascript")]
    fn run_javascript<P: IsA<gio::Cancellable>, Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(&self, script: &str, cancellable: Option<&P>, callback: Q);

    
    fn run_javascript_future(&self, script: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<JavascriptResult, glib::Error>> + 'static>>;

    #[doc(alias = "webkit_web_view_run_javascript_from_gresource")]
    fn run_javascript_from_gresource<P: IsA<gio::Cancellable>, Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(&self, resource: &str, cancellable: Option<&P>, callback: Q);

    
    fn run_javascript_from_gresource_future(&self, resource: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<JavascriptResult, glib::Error>> + 'static>>;

    #[cfg(any(feature = "v2_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_22")))]
    #[doc(alias = "webkit_web_view_run_javascript_in_world")]
    fn run_javascript_in_world<P: IsA<gio::Cancellable>, Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(&self, script: &str, world_name: &str, cancellable: Option<&P>, callback: Q);

    
    #[cfg(any(feature = "v2_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_22")))]
    fn run_javascript_in_world_future(&self, script: &str, world_name: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<JavascriptResult, glib::Error>> + 'static>>;

    #[doc(alias = "webkit_web_view_save")]
    fn save<P: IsA<gio::Cancellable>, Q: FnOnce(Result<gio::InputStream, glib::Error>) + Send + 'static>(&self, save_mode: SaveMode, cancellable: Option<&P>, callback: Q);

    
    fn save_future(&self, save_mode: SaveMode) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::InputStream, glib::Error>> + 'static>>;

    #[doc(alias = "webkit_web_view_save_to_file")]
    fn save_to_file<P: IsA<gio::File>, Q: IsA<gio::Cancellable>, R: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, file: &P, save_mode: SaveMode, cancellable: Option<&Q>, callback: R);

    
    fn save_to_file_future<P: IsA<gio::File> + Clone + 'static>(&self, file: &P, save_mode: SaveMode) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>>;

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    #[doc(alias = "webkit_web_view_send_message_to_page")]
    fn send_message_to_page<P: IsA<UserMessage>, Q: IsA<gio::Cancellable>, R: FnOnce(Result<UserMessage, glib::Error>) + Send + 'static>(&self, message: &P, cancellable: Option<&Q>, callback: R);

    
    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn send_message_to_page_future<P: IsA<UserMessage> + Clone + 'static>(&self, message: &P) -> Pin<Box_<dyn std::future::Future<Output = Result<UserMessage, glib::Error>> + 'static>>;

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "webkit_web_view_set_background_color")]
    fn set_background_color(&self, rgba: &gdk::RGBA);

    #[doc(alias = "webkit_web_view_set_custom_charset")]
    fn set_custom_charset(&self, charset: Option<&str>);

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "webkit_web_view_set_editable")]
    fn set_editable(&self, editable: bool);

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    #[doc(alias = "webkit_web_view_set_input_method_context")]
    fn set_input_method_context<P: IsA<InputMethodContext>>(&self, context: Option<&P>);

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    #[doc(alias = "webkit_web_view_set_is_muted")]
    fn set_is_muted(&self, muted: bool);

    #[doc(alias = "webkit_web_view_set_settings")]
    fn set_settings<P: IsA<Settings>>(&self, settings: &P);

    #[doc(alias = "webkit_web_view_set_zoom_level")]
    fn set_zoom_level(&self, zoom_level: f64);

    #[doc(alias = "webkit_web_view_stop_loading")]
    fn stop_loading(&self);

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    #[doc(alias = "webkit_web_view_try_close")]
    fn try_close(&self);

    #[doc(alias = "web-context")]
    fn web_context(&self) -> Option<WebContext>;

    #[cfg(any(feature = "v2_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
    #[doc(alias = "authenticate")]
    fn connect_authenticate<F: Fn(&Self, &AuthenticationRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "close")]
    fn connect_close<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "context-menu")]
    fn connect_context_menu<F: Fn(&Self, &ContextMenu, &gdk::Event, &HitTestResult) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "context-menu-dismissed")]
    fn connect_context_menu_dismissed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    #[doc(alias = "create")]
    fn connect_create<F: Fn(&Self, &NavigationAction) -> Option<gtk::Widget> + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "decide-policy")]
    fn connect_decide_policy<F: Fn(&Self, &PolicyDecision, PolicyDecisionType) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "enter-fullscreen")]
    fn connect_enter_fullscreen<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "insecure-content-detected")]
    fn connect_insecure_content_detected<F: Fn(&Self, InsecureContentEvent) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "leave-fullscreen")]
    fn connect_leave_fullscreen<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "load-changed")]
    fn connect_load_changed<F: Fn(&Self, LoadEvent) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "load-failed")]
    fn connect_load_failed<F: Fn(&Self, LoadEvent, &str, &glib::Error) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    #[doc(alias = "load-failed-with-tls-errors")]
    fn connect_load_failed_with_tls_errors<F: Fn(&Self, &str, &gio::TlsCertificate, gio::TlsCertificateFlags) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "mouse-target-changed")]
    fn connect_mouse_target_changed<F: Fn(&Self, &HitTestResult, u32) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "permission-request")]
    fn connect_permission_request<F: Fn(&Self, &PermissionRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "print")]
    fn connect_print<F: Fn(&Self, &PrintOperation) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "ready-to-show")]
    fn connect_ready_to_show<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "resource-load-started")]
    fn connect_resource_load_started<F: Fn(&Self, &WebResource, &URIRequest) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "run-as-modal")]
    fn connect_run_as_modal<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "run-color-chooser")]
    fn connect_run_color_chooser<F: Fn(&Self, &ColorChooserRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "run-file-chooser")]
    fn connect_run_file_chooser<F: Fn(&Self, &FileChooserRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "script-dialog")]
    fn connect_script_dialog<F: Fn(&Self, &ScriptDialog) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "show-notification")]
    fn connect_show_notification<F: Fn(&Self, &Notification) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    #[doc(alias = "show-option-menu")]
    fn connect_show_option_menu<F: Fn(&Self, &OptionMenu, &gdk::Event, &gdk::Rectangle) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "submit-form")]
    fn connect_submit_form<F: Fn(&Self, &FormSubmissionRequest) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    #[doc(alias = "user-message-received")]
    fn connect_user_message_received<F: Fn(&Self, &UserMessage) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg_attr(feature = "v2_20", deprecated = "Since 2.20")]
    #[doc(alias = "web-process-crashed")]
    fn connect_web_process_crashed<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
    #[doc(alias = "web-process-terminated")]
    fn connect_web_process_terminated<F: Fn(&Self, WebProcessTerminationReason) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "editable")]
    fn connect_editable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "estimated-load-progress")]
    fn connect_estimated_load_progress_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "favicon")]
    fn connect_favicon_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "is-loading")]
    fn connect_is_loading_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    #[doc(alias = "is-muted")]
    fn connect_is_muted_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    #[doc(alias = "is-playing-audio")]
    fn connect_is_playing_audio_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    #[doc(alias = "page-id")]
    fn connect_page_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    #[doc(alias = "settings")]
    fn connect_settings_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "title")]
    fn connect_title_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "uri")]
    fn connect_uri_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "zoom-level")]
    fn connect_zoom_level_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<WebView>> WebViewExt for O {
    fn can_execute_editing_command<P: IsA<gio::Cancellable>, Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, command: &str, cancellable: Option<&P>, callback: Q) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn can_execute_editing_command_trampoline<Q: FnOnce(Result<(), glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let _ = ffi::webkit_web_view_can_execute_editing_command_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = can_execute_editing_command_trampoline::<Q>;
        unsafe {
            ffi::webkit_web_view_can_execute_editing_command(self.as_ref().to_glib_none().0, command.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn can_execute_editing_command_future(&self, command: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        let command = String::from(command);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.can_execute_editing_command(
                &command,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn can_go_back(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_can_go_back(self.as_ref().to_glib_none().0))
        }
    }

    fn can_go_forward(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_can_go_forward(self.as_ref().to_glib_none().0))
        }
    }

    fn can_show_mime_type(&self, mime_type: &str) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_can_show_mime_type(self.as_ref().to_glib_none().0, mime_type.to_glib_none().0))
        }
    }

    fn download_uri(&self, uri: &str) -> Option<Download> {
        unsafe {
            from_glib_full(ffi::webkit_web_view_download_uri(self.as_ref().to_glib_none().0, uri.to_glib_none().0))
        }
    }

    fn execute_editing_command(&self, command: &str) {
        unsafe {
            ffi::webkit_web_view_execute_editing_command(self.as_ref().to_glib_none().0, command.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_10")))]
    fn execute_editing_command_with_argument(&self, command: &str, argument: &str) {
        unsafe {
            ffi::webkit_web_view_execute_editing_command_with_argument(self.as_ref().to_glib_none().0, command.to_glib_none().0, argument.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn automation_presentation_type(&self) -> AutomationBrowsingContextPresentation {
        unsafe {
            from_glib(ffi::webkit_web_view_get_automation_presentation_type(self.as_ref().to_glib_none().0))
        }
    }

    fn back_forward_list(&self) -> Option<BackForwardList> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_back_forward_list(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn background_color(&self) -> gdk::RGBA {
        unsafe {
            let mut rgba = gdk::RGBA::uninitialized();
            ffi::webkit_web_view_get_background_color(self.as_ref().to_glib_none().0, rgba.to_glib_none_mut().0);
            rgba
        }
    }

    fn context(&self) -> Option<WebContext> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_context(self.as_ref().to_glib_none().0))
        }
    }

    fn custom_charset(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_custom_charset(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_10", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_10")))]
    fn editor_state(&self) -> Option<EditorState> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_editor_state(self.as_ref().to_glib_none().0))
        }
    }

    fn estimated_load_progress(&self) -> f64 {
        unsafe {
            ffi::webkit_web_view_get_estimated_load_progress(self.as_ref().to_glib_none().0)
        }
    }

    fn favicon(&self) -> Option<cairo::Surface> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_favicon(self.as_ref().to_glib_none().0))
        }
    }

    fn find_controller(&self) -> Option<FindController> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_find_controller(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn input_method_context(&self) -> Option<InputMethodContext> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_input_method_context(self.as_ref().to_glib_none().0))
        }
    }

    fn inspector(&self) -> Option<WebInspector> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_inspector(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    fn is_muted(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_get_is_muted(self.as_ref().to_glib_none().0))
        }
    }

    fn javascript_global_context(&self) -> Option<java_script_core::GlobalContextRef> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_javascript_global_context(self.as_ref().to_glib_none().0))
        }
    }

    fn main_resource(&self) -> Option<WebResource> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_main_resource(self.as_ref().to_glib_none().0))
        }
    }

    fn page_id(&self) -> u64 {
        unsafe {
            ffi::webkit_web_view_get_page_id(self.as_ref().to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    fn session_state(&self) -> Option<WebViewSessionState> {
        unsafe {
            from_glib_full(ffi::webkit_web_view_get_session_state(self.as_ref().to_glib_none().0))
        }
    }

    fn settings(&self) -> Option<Settings> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_settings(self.as_ref().to_glib_none().0))
        }
    }

    fn snapshot<P: IsA<gio::Cancellable>, Q: FnOnce(Result<cairo::Surface, glib::Error>) + Send + 'static>(&self, region: SnapshotRegion, options: SnapshotOptions, cancellable: Option<&P>, callback: Q) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn snapshot_trampoline<Q: FnOnce(Result<cairo::Surface, glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let ret = ffi::webkit_web_view_get_snapshot_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = snapshot_trampoline::<Q>;
        unsafe {
            ffi::webkit_web_view_get_snapshot(self.as_ref().to_glib_none().0, region.into_glib(), options.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn snapshot_future(&self, region: SnapshotRegion, options: SnapshotOptions) -> Pin<Box_<dyn std::future::Future<Output = Result<cairo::Surface, glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.snapshot(
                region,
                options,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn title(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_title(self.as_ref().to_glib_none().0))
        }
    }

    fn tls_info(&self) -> Option<(gio::TlsCertificate, gio::TlsCertificateFlags)> {
        unsafe {
            let mut certificate = ptr::null_mut();
            let mut errors = mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::webkit_web_view_get_tls_info(self.as_ref().to_glib_none().0, &mut certificate, errors.as_mut_ptr()));
            let errors = errors.assume_init();
            if ret { Some((from_glib_none(certificate), from_glib(errors))) } else { None }
        }
    }

    fn uri(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_uri(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    fn user_content_manager(&self) -> Option<UserContentManager> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_user_content_manager(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
    fn website_data_manager(&self) -> Option<WebsiteDataManager> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_website_data_manager(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    fn website_policies(&self) -> Option<WebsitePolicies> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_website_policies(self.as_ref().to_glib_none().0))
        }
    }

    fn window_properties(&self) -> Option<WindowProperties> {
        unsafe {
            from_glib_none(ffi::webkit_web_view_get_window_properties(self.as_ref().to_glib_none().0))
        }
    }

    fn zoom_level(&self) -> f64 {
        unsafe {
            ffi::webkit_web_view_get_zoom_level(self.as_ref().to_glib_none().0)
        }
    }

    fn go_back(&self) {
        unsafe {
            ffi::webkit_web_view_go_back(self.as_ref().to_glib_none().0);
        }
    }

    fn go_forward(&self) {
        unsafe {
            ffi::webkit_web_view_go_forward(self.as_ref().to_glib_none().0);
        }
    }

    fn go_to_back_forward_list_item<P: IsA<BackForwardListItem>>(&self, list_item: &P) {
        unsafe {
            ffi::webkit_web_view_go_to_back_forward_list_item(self.as_ref().to_glib_none().0, list_item.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_18", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_18")))]
    fn is_controlled_by_automation(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_is_controlled_by_automation(self.as_ref().to_glib_none().0))
        }
    }

    fn is_editable(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_is_editable(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_16", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
    fn is_ephemeral(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_is_ephemeral(self.as_ref().to_glib_none().0))
        }
    }

    fn is_loading(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_is_loading(self.as_ref().to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn is_playing_audio(&self) -> bool {
        unsafe {
            from_glib(ffi::webkit_web_view_is_playing_audio(self.as_ref().to_glib_none().0))
        }
    }

    fn load_alternate_html(&self, content: &str, content_uri: &str, base_uri: Option<&str>) {
        unsafe {
            ffi::webkit_web_view_load_alternate_html(self.as_ref().to_glib_none().0, content.to_glib_none().0, content_uri.to_glib_none().0, base_uri.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    fn load_bytes(&self, bytes: &glib::Bytes, mime_type: Option<&str>, encoding: Option<&str>, base_uri: Option<&str>) {
        unsafe {
            ffi::webkit_web_view_load_bytes(self.as_ref().to_glib_none().0, bytes.to_glib_none().0, mime_type.to_glib_none().0, encoding.to_glib_none().0, base_uri.to_glib_none().0);
        }
    }

    fn load_html(&self, content: &str, base_uri: Option<&str>) {
        unsafe {
            ffi::webkit_web_view_load_html(self.as_ref().to_glib_none().0, content.to_glib_none().0, base_uri.to_glib_none().0);
        }
    }

    fn load_plain_text(&self, plain_text: &str) {
        unsafe {
            ffi::webkit_web_view_load_plain_text(self.as_ref().to_glib_none().0, plain_text.to_glib_none().0);
        }
    }

    fn load_request<P: IsA<URIRequest>>(&self, request: &P) {
        unsafe {
            ffi::webkit_web_view_load_request(self.as_ref().to_glib_none().0, request.as_ref().to_glib_none().0);
        }
    }

    fn load_uri(&self, uri: &str) {
        unsafe {
            ffi::webkit_web_view_load_uri(self.as_ref().to_glib_none().0, uri.to_glib_none().0);
        }
    }

    fn reload(&self) {
        unsafe {
            ffi::webkit_web_view_reload(self.as_ref().to_glib_none().0);
        }
    }

    fn reload_bypass_cache(&self) {
        unsafe {
            ffi::webkit_web_view_reload_bypass_cache(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    fn restore_session_state(&self, state: &WebViewSessionState) {
        unsafe {
            ffi::webkit_web_view_restore_session_state(self.as_ref().to_glib_none().0, state.to_glib_none().0);
        }
    }

    fn run_javascript<P: IsA<gio::Cancellable>, Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(&self, script: &str, cancellable: Option<&P>, callback: Q) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn run_javascript_trampoline<Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let ret = ffi::webkit_web_view_run_javascript_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = run_javascript_trampoline::<Q>;
        unsafe {
            ffi::webkit_web_view_run_javascript(self.as_ref().to_glib_none().0, script.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn run_javascript_future(&self, script: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<JavascriptResult, glib::Error>> + 'static>> {

        let script = String::from(script);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.run_javascript(
                &script,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn run_javascript_from_gresource<P: IsA<gio::Cancellable>, Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(&self, resource: &str, cancellable: Option<&P>, callback: Q) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn run_javascript_from_gresource_trampoline<Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let ret = ffi::webkit_web_view_run_javascript_from_gresource_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = run_javascript_from_gresource_trampoline::<Q>;
        unsafe {
            ffi::webkit_web_view_run_javascript_from_gresource(self.as_ref().to_glib_none().0, resource.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn run_javascript_from_gresource_future(&self, resource: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<JavascriptResult, glib::Error>> + 'static>> {

        let resource = String::from(resource);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.run_javascript_from_gresource(
                &resource,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[cfg(any(feature = "v2_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_22")))]
    fn run_javascript_in_world<P: IsA<gio::Cancellable>, Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(&self, script: &str, world_name: &str, cancellable: Option<&P>, callback: Q) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn run_javascript_in_world_trampoline<Q: FnOnce(Result<JavascriptResult, glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let ret = ffi::webkit_web_view_run_javascript_in_world_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = run_javascript_in_world_trampoline::<Q>;
        unsafe {
            ffi::webkit_web_view_run_javascript_in_world(self.as_ref().to_glib_none().0, script.to_glib_none().0, world_name.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(any(feature = "v2_22", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_22")))]
    fn run_javascript_in_world_future(&self, script: &str, world_name: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<JavascriptResult, glib::Error>> + 'static>> {

        let script = String::from(script);
        let world_name = String::from(world_name);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.run_javascript_in_world(
                &script,
                &world_name,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn save<P: IsA<gio::Cancellable>, Q: FnOnce(Result<gio::InputStream, glib::Error>) + Send + 'static>(&self, save_mode: SaveMode, cancellable: Option<&P>, callback: Q) {
        let user_data: Box_<Q> = Box_::new(callback);
        unsafe extern "C" fn save_trampoline<Q: FnOnce(Result<gio::InputStream, glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let ret = ffi::webkit_web_view_save_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<Q> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = save_trampoline::<Q>;
        unsafe {
            ffi::webkit_web_view_save(self.as_ref().to_glib_none().0, save_mode.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn save_future(&self, save_mode: SaveMode) -> Pin<Box_<dyn std::future::Future<Output = Result<gio::InputStream, glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.save(
                save_mode,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    fn save_to_file<P: IsA<gio::File>, Q: IsA<gio::Cancellable>, R: FnOnce(Result<(), glib::Error>) + Send + 'static>(&self, file: &P, save_mode: SaveMode, cancellable: Option<&Q>, callback: R) {
        let user_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn save_to_file_trampoline<R: FnOnce(Result<(), glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let _ = ffi::webkit_web_view_save_to_file_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = save_to_file_trampoline::<R>;
        unsafe {
            ffi::webkit_web_view_save_to_file(self.as_ref().to_glib_none().0, file.as_ref().to_glib_none().0, save_mode.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    fn save_to_file_future<P: IsA<gio::File> + Clone + 'static>(&self, file: &P, save_mode: SaveMode) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        let file = file.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.save_to_file(
                &file,
                save_mode,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn send_message_to_page<P: IsA<UserMessage>, Q: IsA<gio::Cancellable>, R: FnOnce(Result<UserMessage, glib::Error>) + Send + 'static>(&self, message: &P, cancellable: Option<&Q>, callback: R) {
        let user_data: Box_<R> = Box_::new(callback);
        unsafe extern "C" fn send_message_to_page_trampoline<R: FnOnce(Result<UserMessage, glib::Error>) + Send + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = ptr::null_mut();
            let ret = ffi::webkit_web_view_send_message_to_page_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<R> = Box_::from_raw(user_data as *mut _);
            callback(result);
        }
        let callback = send_message_to_page_trampoline::<R>;
        unsafe {
            ffi::webkit_web_view_send_message_to_page(self.as_ref().to_glib_none().0, message.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn send_message_to_page_future<P: IsA<UserMessage> + Clone + 'static>(&self, message: &P) -> Pin<Box_<dyn std::future::Future<Output = Result<UserMessage, glib::Error>> + 'static>> {

        let message = message.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.send_message_to_page(
                &message,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn set_background_color(&self, rgba: &gdk::RGBA) {
        unsafe {
            ffi::webkit_web_view_set_background_color(self.as_ref().to_glib_none().0, rgba.to_glib_none().0);
        }
    }

    fn set_custom_charset(&self, charset: Option<&str>) {
        unsafe {
            ffi::webkit_web_view_set_custom_charset(self.as_ref().to_glib_none().0, charset.to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn set_editable(&self, editable: bool) {
        unsafe {
            ffi::webkit_web_view_set_editable(self.as_ref().to_glib_none().0, editable.into_glib());
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn set_input_method_context<P: IsA<InputMethodContext>>(&self, context: Option<&P>) {
        unsafe {
            ffi::webkit_web_view_set_input_method_context(self.as_ref().to_glib_none().0, context.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    fn set_is_muted(&self, muted: bool) {
        unsafe {
            ffi::webkit_web_view_set_is_muted(self.as_ref().to_glib_none().0, muted.into_glib());
        }
    }

    fn set_settings<P: IsA<Settings>>(&self, settings: &P) {
        unsafe {
            ffi::webkit_web_view_set_settings(self.as_ref().to_glib_none().0, settings.as_ref().to_glib_none().0);
        }
    }

    fn set_zoom_level(&self, zoom_level: f64) {
        unsafe {
            ffi::webkit_web_view_set_zoom_level(self.as_ref().to_glib_none().0, zoom_level);
        }
    }

    fn stop_loading(&self) {
        unsafe {
            ffi::webkit_web_view_stop_loading(self.as_ref().to_glib_none().0);
        }
    }

    #[cfg(any(feature = "v2_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_12")))]
    fn try_close(&self) {
        unsafe {
            ffi::webkit_web_view_try_close(self.as_ref().to_glib_none().0);
        }
    }

    fn web_context(&self) -> Option<WebContext> {
        unsafe {
            let mut value = glib::Value::from_type(<WebContext as StaticType>::static_type());
            glib::gobject_ffi::g_object_get_property(self.to_glib_none().0 as *mut glib::gobject_ffi::GObject, b"web-context\0".as_ptr() as *const _, value.to_glib_none_mut().0);
            value.get().expect("Return Value for property `web-context` getter")
        }
    }

    #[cfg(any(feature = "v2_2", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
    fn connect_authenticate<F: Fn(&Self, &AuthenticationRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn authenticate_trampoline<P: IsA<WebView>, F: Fn(&P, &AuthenticationRequest) -> bool + 'static>(this: *mut ffi::WebKitWebView, request: *mut ffi::WebKitAuthenticationRequest, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(request)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"authenticate\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(authenticate_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_close<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn close_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"close\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(close_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_context_menu<F: Fn(&Self, &ContextMenu, &gdk::Event, &HitTestResult) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn context_menu_trampoline<P: IsA<WebView>, F: Fn(&P, &ContextMenu, &gdk::Event, &HitTestResult) -> bool + 'static>(this: *mut ffi::WebKitWebView, context_menu: *mut ffi::WebKitContextMenu, event: *mut gdk::ffi::GdkEvent, hit_test_result: *mut ffi::WebKitHitTestResult, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(context_menu), &from_glib_none(event), &from_glib_borrow(hit_test_result)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"context-menu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(context_menu_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_context_menu_dismissed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn context_menu_dismissed_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"context-menu-dismissed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(context_menu_dismissed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    fn connect_create<F: Fn(&Self, &NavigationAction) -> Option<gtk::Widget> + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn create_trampoline<P: IsA<WebView>, F: Fn(&P, &NavigationAction) -> Option<gtk::Widget> + 'static>(this: *mut ffi::WebKitWebView, navigation_action: *mut ffi::WebKitNavigationAction, f: glib::ffi::gpointer) -> *mut gtk::ffi::GtkWidget {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(navigation_action)).to_glib_full()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"create\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(create_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_decide_policy<F: Fn(&Self, &PolicyDecision, PolicyDecisionType) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn decide_policy_trampoline<P: IsA<WebView>, F: Fn(&P, &PolicyDecision, PolicyDecisionType) -> bool + 'static>(this: *mut ffi::WebKitWebView, decision: *mut ffi::WebKitPolicyDecision, decision_type: ffi::WebKitPolicyDecisionType, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(decision), from_glib(decision_type)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"decide-policy\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(decide_policy_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_enter_fullscreen<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn enter_fullscreen_trampoline<P: IsA<WebView>, F: Fn(&P) -> bool + 'static>(this: *mut ffi::WebKitWebView, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref()).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"enter-fullscreen\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(enter_fullscreen_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_insecure_content_detected<F: Fn(&Self, InsecureContentEvent) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn insecure_content_detected_trampoline<P: IsA<WebView>, F: Fn(&P, InsecureContentEvent) + 'static>(this: *mut ffi::WebKitWebView, event: ffi::WebKitInsecureContentEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), from_glib(event))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"insecure-content-detected\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(insecure_content_detected_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_leave_fullscreen<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn leave_fullscreen_trampoline<P: IsA<WebView>, F: Fn(&P) -> bool + 'static>(this: *mut ffi::WebKitWebView, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref()).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"leave-fullscreen\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(leave_fullscreen_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_load_changed<F: Fn(&Self, LoadEvent) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn load_changed_trampoline<P: IsA<WebView>, F: Fn(&P, LoadEvent) + 'static>(this: *mut ffi::WebKitWebView, load_event: ffi::WebKitLoadEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), from_glib(load_event))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"load-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(load_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_load_failed<F: Fn(&Self, LoadEvent, &str, &glib::Error) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn load_failed_trampoline<P: IsA<WebView>, F: Fn(&P, LoadEvent, &str, &glib::Error) -> bool + 'static>(this: *mut ffi::WebKitWebView, load_event: ffi::WebKitLoadEvent, failing_uri: *mut libc::c_char, error: *mut glib::ffi::GError, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), from_glib(load_event), &glib::GString::from_glib_borrow(failing_uri), &from_glib_borrow(error)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"load-failed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(load_failed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    fn connect_load_failed_with_tls_errors<F: Fn(&Self, &str, &gio::TlsCertificate, gio::TlsCertificateFlags) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn load_failed_with_tls_errors_trampoline<P: IsA<WebView>, F: Fn(&P, &str, &gio::TlsCertificate, gio::TlsCertificateFlags) -> bool + 'static>(this: *mut ffi::WebKitWebView, failing_uri: *mut libc::c_char, certificate: *mut gio::ffi::GTlsCertificate, errors: gio::ffi::GTlsCertificateFlags, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(failing_uri), &from_glib_borrow(certificate), from_glib(errors)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"load-failed-with-tls-errors\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(load_failed_with_tls_errors_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_mouse_target_changed<F: Fn(&Self, &HitTestResult, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn mouse_target_changed_trampoline<P: IsA<WebView>, F: Fn(&P, &HitTestResult, u32) + 'static>(this: *mut ffi::WebKitWebView, hit_test_result: *mut ffi::WebKitHitTestResult, modifiers: libc::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(hit_test_result), modifiers)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"mouse-target-changed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(mouse_target_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_permission_request<F: Fn(&Self, &PermissionRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn permission_request_trampoline<P: IsA<WebView>, F: Fn(&P, &PermissionRequest) -> bool + 'static>(this: *mut ffi::WebKitWebView, request: *mut ffi::WebKitPermissionRequest, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(request)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"permission-request\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(permission_request_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_print<F: Fn(&Self, &PrintOperation) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn print_trampoline<P: IsA<WebView>, F: Fn(&P, &PrintOperation) -> bool + 'static>(this: *mut ffi::WebKitWebView, print_operation: *mut ffi::WebKitPrintOperation, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(print_operation)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"print\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(print_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_ready_to_show<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn ready_to_show_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"ready-to-show\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(ready_to_show_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_resource_load_started<F: Fn(&Self, &WebResource, &URIRequest) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn resource_load_started_trampoline<P: IsA<WebView>, F: Fn(&P, &WebResource, &URIRequest) + 'static>(this: *mut ffi::WebKitWebView, resource: *mut ffi::WebKitWebResource, request: *mut ffi::WebKitURIRequest, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(resource), &from_glib_borrow(request))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"resource-load-started\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(resource_load_started_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_run_as_modal<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn run_as_modal_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"run-as-modal\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(run_as_modal_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn connect_run_color_chooser<F: Fn(&Self, &ColorChooserRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn run_color_chooser_trampoline<P: IsA<WebView>, F: Fn(&P, &ColorChooserRequest) -> bool + 'static>(this: *mut ffi::WebKitWebView, request: *mut ffi::WebKitColorChooserRequest, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(request)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"run-color-chooser\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(run_color_chooser_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_run_file_chooser<F: Fn(&Self, &FileChooserRequest) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn run_file_chooser_trampoline<P: IsA<WebView>, F: Fn(&P, &FileChooserRequest) -> bool + 'static>(this: *mut ffi::WebKitWebView, request: *mut ffi::WebKitFileChooserRequest, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(request)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"run-file-chooser\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(run_file_chooser_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_script_dialog<F: Fn(&Self, &ScriptDialog) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn script_dialog_trampoline<P: IsA<WebView>, F: Fn(&P, &ScriptDialog) -> bool + 'static>(this: *mut ffi::WebKitWebView, dialog: *mut ffi::WebKitScriptDialog, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(dialog)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"script-dialog\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(script_dialog_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn connect_show_notification<F: Fn(&Self, &Notification) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_notification_trampoline<P: IsA<WebView>, F: Fn(&P, &Notification) -> bool + 'static>(this: *mut ffi::WebKitWebView, notification: *mut ffi::WebKitNotification, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(notification)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-notification\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_notification_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn connect_show_option_menu<F: Fn(&Self, &OptionMenu, &gdk::Event, &gdk::Rectangle) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_option_menu_trampoline<P: IsA<WebView>, F: Fn(&P, &OptionMenu, &gdk::Event, &gdk::Rectangle) -> bool + 'static>(this: *mut ffi::WebKitWebView, object: *mut ffi::WebKitOptionMenu, p0: *mut gdk::ffi::GdkEvent, p1: *mut gdk::ffi::GdkRectangle, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(object), &from_glib_none(p0), &from_glib_borrow(p1)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show-option-menu\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_option_menu_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_submit_form<F: Fn(&Self, &FormSubmissionRequest) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn submit_form_trampoline<P: IsA<WebView>, F: Fn(&P, &FormSubmissionRequest) + 'static>(this: *mut ffi::WebKitWebView, request: *mut ffi::WebKitFormSubmissionRequest, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(request))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"submit-form\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(submit_form_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn connect_user_message_received<F: Fn(&Self, &UserMessage) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn user_message_received_trampoline<P: IsA<WebView>, F: Fn(&P, &UserMessage) -> bool + 'static>(this: *mut ffi::WebKitWebView, message: *mut ffi::WebKitUserMessage, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(message)).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"user-message-received\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(user_message_received_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_web_process_crashed<F: Fn(&Self) -> bool + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn web_process_crashed_trampoline<P: IsA<WebView>, F: Fn(&P) -> bool + 'static>(this: *mut ffi::WebKitWebView, f: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref()).into_glib()
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"web-process-crashed\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(web_process_crashed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_20", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
    fn connect_web_process_terminated<F: Fn(&Self, WebProcessTerminationReason) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn web_process_terminated_trampoline<P: IsA<WebView>, F: Fn(&P, WebProcessTerminationReason) + 'static>(this: *mut ffi::WebKitWebView, reason: ffi::WebKitWebProcessTerminationReason, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref(), from_glib(reason))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"web-process-terminated\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(web_process_terminated_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn connect_editable_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_editable_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::editable\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_editable_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_estimated_load_progress_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_estimated_load_progress_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::estimated-load-progress\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_estimated_load_progress_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_favicon_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_favicon_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::favicon\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_favicon_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_is_loading_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_loading_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::is-loading\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_is_loading_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_30", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
    fn connect_is_muted_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_muted_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::is-muted\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_is_muted_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_8", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_8")))]
    fn connect_is_playing_audio_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_playing_audio_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::is-playing-audio\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_is_playing_audio_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_28", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
    fn connect_page_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_page_id_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::page-id\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_page_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(any(feature = "v2_6", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
    fn connect_settings_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_settings_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::settings\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_settings_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_title_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_title_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::title\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_title_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_uri_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uri_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::uri\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_uri_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_zoom_level_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_zoom_level_trampoline<P: IsA<WebView>, F: Fn(&P) + 'static>(this: *mut ffi::WebKitWebView, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(WebView::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::zoom-level\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_zoom_level_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for WebView {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("WebView")
    }
}
